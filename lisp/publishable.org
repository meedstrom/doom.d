#+TITLE: Weird

In retrospect, tangling here makes little sense. I like to sprinkle custom macros like =(quietly)= over my config, which are not appropriate to include in snippets online. And I may stop using some snippets, but that won't diminish their interest factor. Better to write posts separately, copy-pasting snippets (which may very well go out of date). The posts still needn't be full blog posts, they can sit at the front page of my GitHub repository as I envisioned to "contribute to the discussion" on Emacs configs and pull the readers' attention to the most interesting/weird parts of my config.

** Repeat last command N times

You know about numeric arguments -- typing ~C-u 8 0 M-t~ would call ~M-t~ 80 times.

I'm not good at planning ahead like this. I'd rather choose how many times to do it /after the fact/. I'm fond of the =repeat= command, which I bind to ~C-.~, but it has to be spammed to do it many times -- it does not take a numeric prefix. Besides, I wanted numeric postfix, not prefix. Instead of typing

: M-t C-8 C-.

I'd rather type

: M-t C-. 8

The following snippet lets you do just that. Unfortunately it's limited to repeating up to 9 times, if you can extend it please teach me!

#+begin_src elisp :tangle publishable.el
(defun repeat-digit-times ()
  "Repeat the last command an amount of times, only up to 9
  because this command only works when you bind it to the keys 0-9.
  To do something 10 or more times, use the usual digit arguments."
  (interactive)
  ;; bits pasted from `repeat'
  (when (eq last-repeatable-command 'repeat)
    (setq last-repeatable-command repeat-previous-repeated-command))
  (when (eq last-repeatable-command 'repeat-digit-times)
    (message "I thought it was impossible to end up here"))
  ;; bits pasted from `digit-argument'
  (let* ((char (if (integerp last-command-event)
                   last-command-event
                 (get last-command-event 'ascii-character)))
         (digit (- (logand char ?\177) ?0)))
    (dotimes (i digit) (call-interactively #'repeat))))

(setq post-repeat-map (make-sparse-keymap))
(dotimes (i 10)
  (define-key post-repeat-map (kbd (int-to-string i)) #'repeat-digit-times))

(defun enable-post-repeat-map ()
  (set-transient-map post-repeat-map))

;; (add-function :after #'repeat #'enable-post-repeat-map)
#+end_src

The "standard" way of doing this would be the following.

: <F3> C-x z C-8 <F4>

F3 starts recording, C-x z is the repeat-command (or any command you care to substitute), C-8 ensures that the macro will be run 8 times when you end the recording, apparently. F4 ends recording.

** Eshell: prompt with timestamp

Not a big fan of long file paths in the prompt. We have the modeline for that. So I change the prompt to something more appropriate: a timestamp.

It's not straightforward. Everyone who has had the bright idea of a timestamped command prompt has run into the issue of updating it when you run a command, so that the timestamp accurately matches the time you ran it instead of the time the prompt appeared on screen, which could have been days ago. Here you go.

#+begin_src elisp :tangle publishable.el
  (defun my-eshell-timestamp-update ()
    "When added to `eshell-pre-command-hook', the first string --:-- in the
  prompt becomes a timestamp like 13:59 after you run a command."
    (save-excursion
      (forward-line -1)
      (when-let* ((unfilled-timestamp "--:--")
                  (end (search-forward unfilled-timestamp nil t))
                  (beg (- end (length unfilled-timestamp)))
                  (inhibit-read-only t))
        (delete-region beg end)
        (insert (format-time-string "%H:%M"))
        (add-text-properties beg (point) '(font-lock-face eshell-prompt)))))

  (with-eval-after-load 'eshell
    (add-hook 'eshell-pre-command-hook #'my-eshell-timestamp-update)
    (setq eshell-prompt-regexp (rx bol (repeat 7 nonl) " Sir? ")
          eshell-prompt-function (lambda () (concat "[--:--] Sir? "))))
#+end_src

** Universal key for universal arg

This snippet is particularly justified with my as yet unpublished package escape-modality.

#+begin_src elisp
(my-before-keybinds
  ;; Normally, only C-u does universal-arg. Bind M-u and others too. Now we can do
  ;; M-u 5 M-f instead of C-u 5 M-f.
  (general-def "s-u"   #'universal-argument)
  (general-def "M-u"   #'universal-argument)
  (general-def "C-M-u" #'universal-argument)

  ;; general-def doesn't work with (format)
  (dolist (x (string-to-list "1234567890"))
    ;; Unbind C-1234567890 and co. Too good to waste on `digit-argument'.
    (global-unset-key (kbd (format "C-%c" x)))
    (global-unset-key (kbd (format "M-%c" x)))
    (global-unset-key (kbd (format "C-M-%c" x)))
    ;; After C-u/M-u/s-u, ensure that holding down the modifier makes no diff.
    ;; Now we can do M-u M-5 M-f as well as M-u 5 M-f.
    (define-key universal-argument-map (kbd (format "C-%c" x))   #'digit-argument)
    (define-key universal-argument-map (kbd (format "M-%c" x))   #'digit-argument)
    (define-key universal-argument-map (kbd (format "C-M-%c" x)) #'digit-argument)
    (define-key universal-argument-map (kbd (format "s-%c" x))   #'digit-argument)))
#+end_src
